// This script will (eventually) apply each comp and then export to a PDF Presentation with overlays of font information// Written by David Klawitter#target photoshopmain();///////////////////////////////////////////////////////////////////////////// Function: getVisibleTextLayers// Usage: Does a recursive search of layers and collects all text layer references//        in to a single array, layers.// Input: Document, Array///////////////////////////////////////////////////////////////////////////function getVisibleTextLayers(docOrLayerSet, textLayers) {  var layersCount = docOrLayerSet.layers.length;  for (var layersIndex = 0; layersIndex < layersCount; layersIndex++) {    var layer = docOrLayerSet.layers[layersIndex];    if (layer.visible) {      if (layer.typename == "LayerSet") {        getVisibleTextLayers(layer, textLayers);      } else if (isTextLayer(layer)) {        textLayers.push(layer);      }    }  }}///////////////////////////////////////////////////////////////////////////// Function: isTextLayer// Usage: Determines whether or not the layer ref passed in is a text layer// Input: ArtLayer// Return: true if the layer is a text layer///////////////////////////////////////////////////////////////////////////function isTextLayer(layer) {  if (layer.typename == "ArtLayer") {    if (layer.kind == "LayerKind.TEXT") {      return true;    }  }  return false;}function createHintLayer(textItem) {  var artLayerRef = activeDocument.artLayers.add();  artLayerRef.kind = LayerKind.TEXT;  var textItemRef = artLayerRef.textItem;  textItemRef.contents = getFontDisplay(textItem);  var textColor = new SolidColor();  textColor.rgb.red = 255;  textColor.rgb.green = 255;  textColor.rgb.blue = 255;  textItemRef.color = textColor;  textItemRef.size = 10;  return artLayerRef;}///////////////////////////////////////////////////////////////////////////// Function: userFriendlyConstant// Usage: Converts constants to user-friendly copy// Input: string// Return: a string///////////////////////////////////////////////////////////////////////////function userFriendlyConstant(obj) {  if (obj == "TypeUnits.PIXELS")    return "px";  else if (obj == "TypeUnits.POINTS") {    return "pt";  } else {    return obj;  }}///////////////////////////////////////////////////////////////////////////// Function: positionLayer// Usage: Moves a layer to a new position// Input: layerObject, Number, Number///////////////////////////////////////////////////////////////////////////function positionLayer(lyr, x, y) {  if (lyr.iisBackgroundLayer || lyr.positionLocked) {    return;  }  var layerBounds = lyr.bounds;  var layerX = layerBounds[0].value;  var layerY = layerBounds[1].value;  var deltaX = x - layerX;  var deltaY = y - layerY;  lyr.translate(deltaX, deltaY);}///////////////////////////////////////////////////////////////////////////// Function: fillLayer// Usage: Fills a document selection with color used bounds of the provided layer object// Input: Layer///////////////////////////////////////////////////////////////////////////function fillLayer(fillLayer, bounds) {  activeDocument.activeLayer = fillLayer;  var a = [bounds[0], bounds[1]];  var b = [bounds[2], bounds[1]];  var c = [bounds[0], bounds[3]];  var d = [bounds[2], bounds[3]];  var fillColor = new SolidColor();  fillColor.rgb.red = 255;  fillColor.rgb.green = 0;  fillColor.rgb.blue = 0;  activeDocument.selection.select([c, d, b, a], SelectionType.REPLACE, 0, false);  activeDocument.selection.expand('10 pixels');  activeDocument.selection.fill(fillColor, ColorBlendMode.NORMAL, 80, false);}function getFontDisplay(textItemRef) {  return textItemRef.font + '\r' +      Math.round(textItemRef.size) + ' ' + userFriendlyConstant(app.preferences.typeUnits) + '\r' +      '#' + textItemRef.color.rgb.hexValue;}function exportPng(fileName) {  var docExportOptions = new ExportOptionsSaveForWeb();  docExportOptions.format = SaveDocumentType.PNG;  docExportOptions.transparency = true;  docExportOptions.blur = 0.0;  docExportOptions.includeProfile = false;  docExportOptions.interlaced = false;  docExportOptions.optimized = true;  docExportOptions.quality = 100;  docExportOptions.PNG8 = false;  var file = new File(activeDocument.path + '/' + fileName);  activeDocument.exportDocument(file, ExportType.SAVEFORWEB, docExportOptions);}function main() {  if (documents.length <= 0) {    alert('Please open a document.');    return;  }  var fileName = activeDocument.name;  fileName = fileName.substr(0, fileName.lastIndexOf('.'));  var layerCompsCount = activeDocument.layerComps.length;  for (var layerCompsIndex = 0; layerCompsIndex < 1; layerCompsIndex++) {    var layerCompRef = activeDocument.layerComps[layerCompsIndex];    layerCompRef.apply();    exportPng(fileName + '_' + layerCompRef.name + '.png');    var textLayers = [];    getVisibleTextLayers(app.activeDocument, textLayers);    var layerSet = activeDocument.layerSets.add();    layerSet.name = layerCompRef.name + ' Redlines';    var fillLayerRef = activeDocument.artLayers.add();    fillLayerRef.kind = LayerKind.NORMAL;    fillLayerRef.move(layerSet, ElementPlacement.INSIDE);    for (var layerIndex = 0; layerIndex < textLayers.length; layerIndex++) {      var layer = textLayers[layerIndex];      var artLayerRef = createHintLayer(layer.textItem);      artLayerRef.move(layerSet, ElementPlacement.INSIDE);      positionLayer(artLayerRef, layer.bounds[0], layer.bounds[1]);            fillLayer(fillLayerRef, artLayerRef.bounds);    }    layerSet.merge();    exportPng(fileName + '_' + layerCompRef.name + '_redline.png');  }}